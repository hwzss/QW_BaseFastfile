
    # all options is there:
    # >>>>>>>>>>>>>>
    #   release
    #   pod_install
    #   version
    #   ipa_out_put_dir
    #   scheme_name
    #   auto_increment_version
    #   build_num
    #   deliver: 上传到哪里  testfilght, pgy, app-store
    #   export_method ：出包方法 app-store, ad-hoc, package, enterprise, development
    # >>>>>>>>>>>>>>

    # there is a simple code for use to upload ipa file to testfltght
    # upload_ipa_to_testfltght(
    #   release: true,
    #   pod_install: op[:pod_install],
    #   version: op[:version],
    #   ipa_out_put_dir: op[:ipa_out_put_dir],
    #   scheme_name: op[:scheme_name],
    #   auto_increment_version: op[:auto_increment_version],
    #   build_num: op[:build_num]
    # )


# fastlane_version "2.62.0"

default_platform :ios

platform :ios do

  ENV['FASTLANE_XCODEBUILD_SETTINGS_TIMEOUT'] = '60'
  ENV['FASTLANE_XCODEBUILD_SETTINGS_RETRIES'] = '10'

  before_all do
       xcode_select "/Applications/Xcode.app"
  end

  desc "Upload an release/debug ipa to TestFilght"
  lane :upload_ipa_to_testfltght do |op|
      
      # for debug test
      # puts "build_num#{op[:build_num]}"
      # puts "auto_increment_version#{op[:auto_increment_version]}"
      # puts "release#{op[:release]}"
      # puts "pod_install#{op[:pod_install]}"
      # puts "version#{op[:version]}"
      # puts "scheme_name#{op[:scheme_name]}"
      # puts "ipa_out_put_dir#{op[:ipa_out_put_dir]}"
      # puts "@@@@@@@@@@@@@@@@@@@@@@@"
      is_release = op[:release]

      cocoapods if op[:pod_install]
 
      version_number = verify_version_lane version:op[:version]                  
      out_put_dir = verify_ipa_out_put_dir_lane ipa_out_put_dir:op[:ipa_out_put_dir]
      unless Dir.exist?(File.expand_path("#{out_put_dir}"))
          UI.error("#{out_put_dir} 路径不存在，请填写正确的打包路径")   
          out_put_dir = UI.input("请输入打包路径:")

          unless Dir.exist?(File.expand_path("#{out_put_dir}"))
            UI.error("#{out_put_dir} 路径不存在，结束任务...")             
            next
          end 
      end 

      String.include(VersionFactory)
      if version_number
          #补齐A.B.C格式
          version_number.formatABC
          version_number = increment_version_number(version_number: version_number)
      elsif op[:auto_increment_version]
          version_number = get_version_number 
          #补齐A.B.C格式
          version_number = version_number.formatABC 
          version_number = version_number.increment
          version_number = increment_version_number(version_number: version_number)
      end
            
      build_number = op[:build_num]      
      unless op[:auto_increment_version] && op[:version]        
        # if version number not be given and can not auto increment then increment build number
        String.include(BuildNumberFactory)    
        if build_number          
          # increment by given build number
          build_number.is_build_avalable
          increment_build_number(build_number: build_number)
        else         
          # build number not be givend then auto increment   
          build_number = get_build_number               
          build_number = build_number.formatBuildNumber
          build_number.is_build_avalable
          build_number = build_number.incrementBuild 
          increment_build_number(build_number: build_number) 
        end
              
      end
                      
      #out ipa file path      
      # sub_dir_name = is_release ? "release" : "debugBeta"
      # full_output_dir = "#{out_put_dir}/#{sub_dir_name}"

      # Dir.mkdir(File.expand_path("#{full_output_dir}")) unless Dir.exist?(File.expand_path("#{full_output_dir}"))

      # version_number = get_version_number unless version_number
      # out_ipa_name = is_release ? "release_#{version_number}_build_#{build_number}" : "debugBeta_#{version_number}_build_#{build_number}"

      # gym_configuration = is_release ? "Release" : "Debug"

      # scheme_name = verify_shceme_lane scheme_name:op[:scheme_name]
      # # puts "scheme_name:#{scheme_name}"

      # # TODO: 添加export-method 支持 , export_method ：出包方法 app-store, ad-hoc, package, enterprise, development
      export_method = op[:export_method]? op[:export_method]: "app-store"

      unless ["app-store", "ad-hoc", "package", "enterprise", "development"].include?export_method
          #TODO: 列出可以选择的选项
          puts "列出可以选择的选项"
          export_method = MCFactory.wait_to_input(["app-store", "ad-hoc", "package", "enterprise", "development"], "#{export_method}格式不对! 请输入正确的ipa打包格式，如")
          puts "export_method:#{export_method}"
          # export_method = UI.input("#{export_method}格式不对! 请输入正确的ipa打包格式，如app-store")
      end               

      # gym(
      #   scheme: scheme_name,
      #   output_directory: full_output_dir,
      #   silent: true,
      #   clean: false,
      #   configuration: gym_configuration,
      #   output_name: out_ipa_name,
      #   export_xcargs: "-allowProvisioningUpdates",
      #   export_method: export_method
      # ) 

      # TODO: 添加上传到友盟支持 deliver: 上传到哪里  testfilght, pgy, app-store
      deliver_type = op[:deliver]? op[:deliver] : "testfilght"

      unless ["app-store", "pgy", "testfilght"].include? deliver_type
          #TODO: 列出可以选择的选项
          deliver_type = wait_to_input(["app-store", "pgy", "testfilght"], "#{deliver}格式不对! 请输入正确的格式，如:")
          # deliver_type = UI.input("#{export_method}格式不对! 请输入正确的ipa打包格式，如app-store")
      end   

      case deliver_type
        when "testfilght"
          puts "上传testFilght"
          # pilot(
          #   ipa:"#{full_output_dir}/#{out_ipa_name}.ipa"
          # ) 
        when "pgy"
          sh("fastlane add_plugin pgyer")
          puts "上传蒲公英"
        when "app-store"
          puts "上传APPStore"
        else                
          puts "#{deliver_type}打包方式不对，任务结束"
      end

      
  end 


  desc "检测version参数,不存在时就提示"
  lane :verify_version_lane do |options|
    
      unless options[:version]
        UI.message " ************************************************
         *  ⏰ 您未输入ipa的版本，将根据项目build版本进行自增
         *  您可以通过传入version来指定生成特定的版本号，或者通过指定build_num来设定构建版本
         *  比如: fastlane release version:1.0.0 或者 fastlane release build_num:2 反之根据当前build自增
         ************************************************"
      end
      options[:version]
  end

  desc "检测scheme，不存在时提示可设置"
  lane :verify_shceme_lane do |options|
      unless options[:scheme_name]
          UI.message " ************************************************
         *  ⏰ 您未指定特定的scheme,系统XcoudeBulid 将列出所有scheme让你选择
         *  您可以通过传入scheme_name来指定shceme
         *  比如: fastlane release scheme_name:\"cloudIM\" 
         ************************************************"
      end
      options[:scheme_name]
  end

  desc "检测ipa打包路径，未设置时，要求输入路径"
  lane :verify_ipa_out_put_dir_lane do |options|
       unless options[:ipa_out_put_dir]
        UI.message " ************************************************
         *  ❌ 未设定ipa打包路径,必须设定一个当前的ipa打包路径，否则ipa将打出在当前项目路径
         *  您可以通过传入ipa_out_put_dir来指定路径
         *  比如: fastlane release ipa_out_put_dir:\"~/desketop/打包\"   
         ************************************************"
        options[:ipa_out_put_dir] = UI.input("请输入打包路径:")
      end
      options[:ipa_out_put_dir]
  end

end

module MCFactory
    
  def wait_to_input(input_choices, message) 
      puts "sadfas来了。。。。。"     
      UI.message(message)
      #遍历输出数组
      input_choices.each_with_index do |elem, i|
        puts "#{i.to_s}: #{elem}"
      end

      #等待输入
      input_result = UI.input("请输入(0,1,2,3.....):")
      unless input_choices.include? input_result
          input_result = input_choices[input_result]
      end
      input_result
  end
  
  module_function :wait_to_input
end

# 指定给String实例

module BuildNumberFactory
  
  def is_build_avalable
      unless self =~ /^\d{1,}$/
          puts "build_number格式不对，正确格式应该为整数"
      end
  end
  
  def formatBuildNumber
      build_arrs = self.split('.').map(&:to_i);
      build_number = build_arrs.last;
      build_number = 0 unless build_number;
      build_number.to_s
  end

  def incrementBuild
      build_arrs = self.split('.').map(&:to_i);
      build_number = build_arrs[0];
      if build_number
        build_number = build_number + 1
      else
        build_number = 0
      end

      build_number.to_s
  end
  
end


module VersionFactory

def is_available

  unless self =~ /^\d{1,}.\d.\d$/
    puts "version_number格式不对，正确格式应该为 A.B.C "
    return false
  end
  true  
end

# 满足／^\d{1,}*／的值格式成 A.B.C的形式
def formatABC

  version_arrs = self.split('.')
  
  version_arrs << "0" if version_arrs.count == 1
  version_arrs << "0" if version_arrs.count == 2

  temp_version_number = version_arrs[0..2].join('.')
end

# 将满足正则/^\d{1,}.\d.\d$/ 的值进行自增1
def increment

  version_arrs = self.split('.').map(&:to_i)

  if self =~ /^\d{1,}.[0-8].9$|^\d{1,}.[0-8].\d{2,}$/
  
     version_arrs[1] = version_arrs[1] + 1
     version_arrs[2] = 0  
  elsif self =~ /^\d{1,}.9.9$|\d{1,}.\d{2,}.\d{2,}$/
     
     version_arrs[0] = version_arrs[0] + 1
     version_arrs[1] = 0
     version_arrs[2] = 0
  else
      version_arrs[2] = version_arrs[2] + 1

  end

  version_arrs[0..2].join('.')

end


end